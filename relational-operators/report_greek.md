# Διαχείριση Σύνθετων Δεδομένων

## Εργασία 1 : Υλοποίηση Σχεσιακών Τελεστών

### Χρήστος Δημητρέσης         4351            cs04351@uoi.gr

---

##### How to run :

```bash
g++ main.cpp
./a.out R_sorted.tsv S_sorted.tsv R.tsv
```

---

#### Merge-join :

Διαβάζουμε τα 2 αρχεία εισόδου γραμμή-γραμμή κάνοντας μόνο ένα πέρασμα από το καθένα σύμφωνα με τις απαιτήσεις της εκφώνησης.

Στην αρχή διαβάζουμε την πρώτη γραμμή και από τα 2 αρχεία.

* Εάν το κλειδί στην εγγραφή του αρχείο r_sorted είναι μικρότερο λεξικογραφικά απο το κλειδί στη εγγραφή του αρχείου s_sorted προχωράμε στην επόμενη εγγραφή του r_sorted κρατώντας την ίδια εγγραφή του s_sorted.

* Εάν το κλειδί στην εγγραφή του αρχείου r_sorted είναι μεγαλύτερο λεξικογραφικά απο το κλειδί στην εγγραφή του αρχείου s_sorted προχωράμε στην επόμενη εγγραφή του s_sorted κρατώντας την ίδια εγγραφή για το r_sorted

* Εάν το κλειδί στην εγγραφή του αρχείου r_sorted ταυτίζεται λεξικογραφικά με το κλειδι στην εγγραφή του αρχείου s_sorted , τότε :
  
  * Όσο οι εγγραφές στο αρχείο s_sorted έχουν ίδιο κλειδί με την εγγραφή στο αρχείο r_sorted , προσθέτουμε τις εγγραφές αυτές στον buffer.
  
  * Με το που σταματήσουν να ταυτίζονται τα κλειδια των εγγραφών του αρχείου s_sorted με το κλειδι της εγγραφης απο το αρχείο r_sorted κάνουμε το merge-join του κλειδιού από το αρχείο r_sorted με όλες τις εγγραφές του s_sorted που υπάρχουν στον buffer.
  
  * Σε περίπτωση που το αρχείο r_sorted έχει παραπάνω από μια εγγραφές με το ίδιο αυτό κλείδι για το οποίο υπήρξε match με το αρχείο s_sorted , ξανακάνουμε merge-join με όλες τις εγγραφές από τον s buffer.
  
  * Τέλος καθαρίζουμε τον buffer και κρατάμε το μέγιστο μέγεθος στο οποίο έχει φτάσει έως τώρα

Υπάρχουν και σχόλια στον κώδικα για περισσότερες λεπτομέρειες της υλοποίησης.

---

#### Union :

Διαβάζουμε τα 2 αρχεία εισόδου γραμμή-γραμμή κάνοντας μόνο ένα πέρασμα από το καθένα σύμφωνα με τις απαιτήσεις της εκφώνησης.

Στην αρχή διαβάζουμε την πρώτη γραμμή και από τα 2 αρχεία.

* Αν και τα 2 αρχεία έχουν εγγραφές
  
  * Αν η εγγραφή του αρχείου r_sorted είναι μικρότερη λεξικογραφικά απο την εγγραφή του αρχείου s_sorted τότε γράφουμε την εγγραφη του r_sorted στο αρχείο εξόδου και προχωράμε παρακάτω μόνο στο αρχείο r_sorted.
  
  * Εάν η εγγραφή του αρχείου r_sorted είναι μικρότερη λεξικογραφικά απο την εγγραφή του αρχείου s_sorted  τότε γράφουμε την εγγραφή του αρχείου s_sorted στο αρχείο εξόδου και προχωράμε παρακάτω μόνο στο αρχείο s_sorted.
  
  * Έαν οι εγγραφές ταυτίζονται γράφουμε την κοινή αυτή εγγραφή μια φορά μόνο και προχωράμε και στα 2 αρχεία.

* Εάν μόνο το αρχείο r_sorted έχει εγγραφές ακόμα και σε αυτό το σημείο το s_sorted αρχείο έχει τελειώσει ή ήταν εξ-αρχής κενο , γράφουμε όλες τις εναπομείναντες εγγραφές του r_sorted στο αρχειο εξόδου.

* Εάν μόνο το αρχείο s_sorted έχει εγγραφές ακόμα και σε αυτό το σημείο το r_sorted αρχείο έχει τελείωσει η ήταν εξ-αρχής κένο , γράφουμε όλες τις εναπομείναντες εγγραφές του s_sorted στο αρχειο εξόδου.

Προκειμένου να εξασφαλίσουμε ότι δεν θα υπάρχουν διπλότυπα στο αρχείο εξόδου πριν γράψουμε μια εγγραφή, ελέγχουμε εάν ταυτίζεται με την τελευταία εγγραφή που έχει γίνει και αν ναι την αγνοούμε. Επειδη τα αρχεία εισόδου είναι ταξινομημένα όλα τα διπλότυπα θα πάνε να προσθέτουν σειριακά και άρα αυτός ο έλεγχος αρκεί.

---

#### Intersection :

Διαβάζουμε τα 2 αρχεία εισόδου γραμμή-γραμμή κάνοντας μόνο ένα πέρασμα από το καθένα σύμφωνα με τις απαιτήσεις της εκφώνησης.

Στην αρχή διαβάζουμε την πρώτη γραμμή και από τα 2 αρχεία.

- Αν και τα 2 αρχεία έχουν εγγραφές
  
  - Αν η εγγραφή του αρχείου r_sorted είναι μικρότερη λεξικογραφικά απο την εγγραφή του αρχείου s_sorted τότε προχωράμε παρακάτω στο αρχείο r_sorted και δεν γράφουμε τίποτα.
  
  - Εάν η εγγραφή του αρχείου r_sorted είναι μικρότερη λεξικογραφικά απο την εγγραφή του αρχείου s_sorted τότε προχωράμε παρακάτω στο αρχείο s_sorted και δεν γράφουμε τίποτα.
  
  - Έαν οι εγγραφές ταυτίζονται γράφουμε την κοινή αυτή εγγραφή μια φορά μόνο και προχωράμε και στα 2 αρχεία.

Προκειμένου να εξασφαλίσουμε ότι δεν θα υπάρχουν διπλότυπα στο αρχείο εξόδου πριν γράψουμε μια εγγραφή, ελέγχουμε εάν ταυτίζεται με την τελευταία εγγραφή που έχει γίνει και αν ναι την αγνοούμε. Επειδή τα αρχεία εισόδου είναι ταξινομημένα όλα τα διπλότυπα θα πάνε να προσθέτουν σειριακά και άρα αυτός ο έλεγχος αρκεί.

--- 

#### Difference (R_sorted - S_sorted) :

Διαβάζουμε τα 2 αρχεία εισόδου γραμμή-γραμμή κάνοντας μόνο ένα πέρασμα από το καθένα σύμφωνα με τις απαιτήσεις της εκφώνησης.

Στην αρχή διαβάζουμε την πρώτη γραμμή και από τα 2 αρχεία.

-  Όσο το άρχειο r_sorted έχει ακόμα εγγραφές :
  
  - Έαν το άρχειο s_sorted δεν έχει εγγραφές σε αυτό το σημείο ή η εγγραφή του r_sorted είναι μικρότερη λεξικογραφικά απο την εγγραφή του s_sorted τότε γράφουμε την εγγραφή του r_sorted στο αρχείο εξόδου και προχωράμε στο αρχείο r_sorted παρακάτω.
  
  - Εάν η εγγραφή του r_sorted είναι μεγαλύτερη λεξικογραφικά απο την εγγραφή στο αρχείο s_sorted προχωράμε παρακάτω στο αρχείο r_sorted
  
  - Εάν οι εγγραφές είναι ίδιες και στα 2 αρχεία , προχωράμε παρακάτω και στα 2 αρχεία.

Προκειμένου να εξασφαλίσουμε ότι δεν θα υπάρχουν διπλότυπα στο αρχείο εξόδου πριν γράψουμε μια εγγραφή, ελέγχουμε εάν ταυτίζεται με την τελευταία εγγραφή που έχει γίνει και αν ναι την αγνοούμε. Επειδή τα αρχεία εισόδου είναι ταξινομημένα όλα τα διπλότυπα θα πάνε να προσθέτουν σειριακά και άρα αυτός ο έλεγχος αρκεί.

---

#### RgroupBy with Aggregation :

Δημιουργούμε ένα struct ονόματι Record προκείμενου να μπορούμε να αποθηκεύσουμε και να διαχειριστούμε τις εγγραφές του αρχείου R αποδοτικά.

Δημιουργούμε μια λίστα η οποία περιέχει όλες τις εγγραφές του αρχείου R.tsv με το κάθε Record να αποτελεί και μια εγγραφή.

Εκτελούμε τον αλγόριθμο merge Sort στα στοιχεία της λίστας αυτής και στο τέλος γράφουμε την λίστα με τις εγγραφές που προκύπτουν στο αρχείο εξόδου

Η υλοποίηση του αλγορίθμου mergeSort είναι ακριβώς ίδια με την υλοποίηση του κανονικού αλγόριθμου με την διαφορά ότι όταν γίνεται merge των ταξινομημένων λιστών που προκύπτουν, σε περίπτωση ισοτητας (δηλάδη ίδιου κλειδίου) των στοιχείων δημιουργείται ένα νέο Record. Το κλειδί του νέου αντικειμένου παραμένει το ίδιο, ενώ το δεύτερο πεδίο του προκύπτει ως το άθροισμα των αντίστοιχων πεδίων των δύο στοιχείων, για αυτό και η συνάρτηση έχει ονομαστεί merge_with_aggregation.

Όλα τα υπόλοιπα βήματα του κώδικα ακολουθούν την λογική του κανονικού merge-Sort.

---
